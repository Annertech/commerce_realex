<?php

/**
 * @file
 * Integrate Realex Payments gateway with Drupal Commerce.
 */

/**
 * @todo
 *   - abstract the helper functions some more for other method types
 *   - add support for DCC transactions
 *   - add support for 3D secure
 *   - add Redirect integration
 */

/**
 * Implements hook_commerce_payment_method_info().
 */
function commerce_realex_commerce_payment_method_info() {
  $payment_methods = array();

  $payment_methods['commerce_realex_remote'] = array(
    'title' => t('Realex Remote'),
    'short_title' => t('Realex'),
    'display_title' => t('Realex'),
    'description' => t('Integration with Realex using Remote API method.'),
    'active' => TRUE,
    'callbacks' => array(
      'settings_form' => 'commerce_realex_remote_commerce_payment_method_settings_form',
      'submit_form' => 'commerce_realex_remote_commerce_payment_method_submit_form',
      'submit_form_validate' => 'commerce_realex_remote_commerce_payment_method_submit_form_validate',
      'submit_form_submit' => 'commerce_realex_remote_commerce_payment_method_submit_form_submit',
    ),
    'file' => 'commerce_realex_remote.inc',
  );

  return $payment_methods;
}

/**
 * Process the Realex response.
 *
 * @param $response
 *   Parsed response as an array.
 * @param $request
 *   Transaction details array.
 * @param $order
 *   Commerce order object.
 * @param $payment_method
 *   Payment method array.
 */
function _commerce_realex_process_response($request, $response, $order, $payment_method) {
  if (!isset($response['result'])) {
    watchdog('commerce_realex', 'No results code, something has gone wrong with the transaction.', array(), WATCHDOG_ERROR);
    drupal_goto('checkout/' . $order->order_number . '/payment');
  }
  $order_status = commerce_order_status_load($order->status);

  $merchantid = $request['merchantid'];
  $secret = $request['secret'];
  $orderid = $request['orderid'];
  $timestamp = $response['timestamp'];
  $resultcode = $response['result'];
  $message = $response['message'];
  $pasref = $response['pasref'];
  $authcode = $response['authcode'];

  // This digital signature should correspond to the one Realex Payments returns
  // and can therefore be used to verify the message Realex sends back.
  $tmp = "$timestamp.$merchantid.$orderid.$resultcode.$message.$pasref.$authcode";
  $sha1hash = sha1($tmp);
  $tmp = "$sha1hash.$secret";
  $sha1hash = sha1($tmp);

  $success = FALSE;
  $transaction = NULL;
  switch ($response['result']) {
    case '00':
      // Check to see if hashes match or not
      if ($sha1hash != $response['sha1hash']) {
        watchdog('commerce_realex', 'Hash match failed for order @order_id.', array('@order_id' => $response['orderid']));
        drupal_set_message(t("Hashes don't match - response not authenticated!"), 'error');
        $message = 'Bank connection error, please try again later';
        $success = FALSE;
      }
      else {
        // Save the transaction.
        $transaction = commerce_realex_transaction_save($payment_method, $order, $response);
        $success = TRUE;
      }
      break;

    default:
      $success = FALSE;
      break;
  }

  // Successful payment.
  if ($success) {
    $order->data['commerce_realex_remote'] = $pane_values;
    $order->data['commerce_realex_remote']['transaction'] = $transaction;
  }

  // Payment failure.
  else {
    drupal_set_message(t('We were unable to process your credit card payment; reason provided by bank: %message. If the problem persists, contact us to complete your order.', array('%message' => $message)), 'warning');
    watchdog('commerce_realex', 'Payment failed: %message', array('%message' => $message), WATCHDOG_WARNING);
    $_SESSION['realex_failures']++;
    drupal_goto('checkout');
  }
}

/**
 * Generate xml
 *
 * @param request
 *     An array with all the transaction data.
 */
function _commerce_realex_build_xml_request($request) {
  $ip_address = ip_address();
  $xml = "<request type='auth' timestamp='" . $request['timestamp'] . "'>
    <merchantid>" . $request['merchantid'] . "</merchantid>
    <account>" . $request['account'] . "</account>
    <orderid>" . $request['orderid'] . "</orderid>
    <amount currency='" . $request['currency'] . "'>" . $request['amount'] . "</amount>
    <card>
      <number>" . $request['ccnumber'] . "</number>
      <expdate>" . $request['expiry_date'] . "</expdate>
      <type>" . $request['cctype'] . "</type>
      <chname>" . $request['chname'] . "</chname>
      <issueno>" . $request['issueno'] . "</issueno>
    </card>";
  if (isset($request['cvn'])) {
    $xml .="
      <cvn>
        <number>" . $request['cvn'] . "</number>
        <presind>1</presind>
      </cvn>";
  }
  $xml .= "
    <autosettle flag='" . $request['auto_settle'] . "'/>
    <sha1hash>" . $request['sha1hash'] . "</sha1hash>
    <tssinfo>
    <address type=\"billing\">
    <country>ie</country>
    </address>
        <custipaddress>$ip_address</custipaddress>
        <custnum>" . $request['customer_id'] . "</custnum>
        <prodid>" . $request['products'] . "</prodid>
    </tssinfo>
  </request>";

  return $xml;
}

/**
 * Save the transaction and update the order.
 *
 * @param $payment_method
 *   Payment method array.
 * @param $order
 *   Commerce order object.
 * @param $response
 *   Response data.
 */
function commerce_realex_transaction_save($payment_method, $order, $response) {
  $transaction = commerce_payment_transaction_new('commerce_realex_remote', $order->order_id);
  $transaction->amount = $order->commerce_order_total['und'][0]['amount'];
  $transaction->currency_code = $order->commerce_order_total['und'][0]['currency_code'];
  $transaction->instance_id = $payment_method['instance_id'];
  $transaction->remote_id = $response['orderid'];

  // Set the payment status.
  switch ($response['result']) {
    case '00':
      $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
      break;
    default:
      $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
  }

  // Log the response variables.
  $transaction->message = 'Status @resultcode, @message. Order ID: @orderid, Auth code: @authcode, Timestamp: @timestamp, Pasref: @pasref, Address check: @address, Postcode check: @postcode, CVN result: @cvn';
  $transaction->message_variables = array(
    '@resultcode' => $response['result'],
    '@message' => $response['message'],
    '@orderid' => $response['orderid'],
    '@authcode' => $response['authcode'],
    '@timestamp' => $response['timestamp'],
    '@pasref' => $response['pasref'],
    '@address' => $response['avsaddressresponse'],
    '@postcode' => $response['avspostcoderesponse'],
    '@cvn' => $response['cvnresult'],
  );

  commerce_payment_transaction_save($transaction);

  return $transaction;
}

/**
 * Send the request to Realex Payments.
 *
 * @param $url
 *   URL to send the request to.
 * @param $data
 *   XML request message to send.
 * @return
 *   Parsed response object.
 */
function _commerce_realex_send_request($url, $data) {
  $ch = curl_init();
  curl_setopt($ch, CURLOPT_URL, $url);
  curl_setopt($ch, CURLOPT_POST, 1);
  curl_setopt($ch, CURLOPT_USERAGENT, 'payandshop.com php version 0.9');
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
  curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
  curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE); // this line makes it work under https
  $response = curl_exec($ch);
  curl_close($ch);

  // Tidy it up.
  $response = eregi_replace("[[:space:]]+", " ", $response);
  $response = eregi_replace("[\n\r]", "", $response);

  // Parse the XML response.
  $response_obj = new RealexParser($response);
  $result = $response_obj->record;

  return $result;
}

/**
 * Map card types to codes expected by Realex.
 *
 * @param $card
 *   Card name.
 * @return
 *   Realex card type code.
 */
function _commerce_realex_get_card_type($card) {
  switch ($card) {
    case 'mastercard':
      return 'MC';
    case 'amex':
      return 'AMEX';
    case 'solo':
      return 'SWITCH';
    case 'laser':
      return 'LASER';
    case 'dc':
      return 'DINERS';
    case 'visa':
    case 'delta':
    default:
      return 'VISA';
  }
}

/**
 * Parse the response XML and create and object.
 *
 * Code below is based on sample code provided by Realex at http://resource.realexpayments.com/m.php?ct=integration_oscode.php
 */
class RealexParser {

   // Initialise variables.
   var $parser;
   var $record;
   var $timestamp;
   var $field_type;

  function RealexParser($response) {
    // Create and initialise XML parser
    $this->parser = xml_parser_create();
    xml_set_object($this->parser, $this);
    xml_set_element_handler($this->parser, 'startElement', 'endElement');
    xml_set_character_data_handler($this->parser, 'cDataHandler');

    // 1 = single field, 2 = array field, 3 = record container
    $this->field_type = array('response' =>1,
                              'orderid' => 1,
                              'authcode' => 1,
                              'result' => 2,
                              'message' => 1,
                              'pasref' => 1,
                              'batchid' => 1,
                              'md5hash' => 1,
                              'sha1hash' => 1,
                              'cvnresult' => 1,
                              'dccinfo' => 2,
                              'cardholdercurrency' => 1,
                              'cardholderamount' => 1,
                              'cardholderrate' => 1,
                              'merchantcurrency' => 1,
                              'merchantamount' => 1,
                        );

    xml_parse($this->parser, $response);
    xml_parser_free($this->parser);
  }

  /**
   * The 'startElement()' function is called when an open element tag is found.
   * It creates a variable on the fly contructed of all the parent elements
   * joined together with an underscore. So the following xml:
   * <response><something>Owen</something></response>
   * would create two variables:  $RESPONSE and $RESPONSE_SOMETHING
   */
  function startElement($parser, $element, &$attrs) {
    $element = strtolower($element);
      $this->current_field = $element;

    if ($element == 'response' && $attrs['TIMESTAMP']) {
      $this->record['timestamp'] = $attrs['TIMESTAMP'];
    }
  }

  function endElement($parser, $element) {
    $element = strtolower($element);
    // $this->current_field = '';
  }

  /**
   * The 'cDataHandler()' function is called when the parser encounters any text that's
   * not an element. Simply places the text found in the variable that
   * was last created. So using the XML example above the text 'Owen'
   * would be placed in the variable $RESPONSE_SOMETHING
   */
  function cDataHandler($parser, $text) {
    if ($text != ' ') {
      if (!empty($this->current_field)) {
        $this->record[$this->current_field] = $text;
      }
    }
  }
}

